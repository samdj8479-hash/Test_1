<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Beginnings - Orbital Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #2a2a2a 0%, #3a3a3a 100%);
            color: #f0f0f0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            background-color: rgba(42, 42, 42, 0.8);
        }

        .menu-icon {
            font-size: 28px;
            cursor: pointer;
            background: none;
            border: none;
            color: #f0f0f0;
        }

        .lang-sound {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .lang, .sound {
            cursor: pointer;
            font-size: 14px;
            background: none;
            border: none;
            color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }

        .sound svg {
            transition: opacity 0.3s ease;
        }

        .sound.muted svg {
            opacity: 0.3;
        }

        .sidebar {
            position: fixed;
            left: -300px;
            top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(42, 42, 42, 0.98);
            z-index: 2000;
            transition: left 0.3s ease;
            padding: 80px 30px 30px 30px;
            overflow-y: auto;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-title {
            font-size: 24px;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 30px;
            color: #f0f0f0;
            font-weight: bold;
        }

        .game-item {
            padding: 20px;
            margin-bottom: 15px;
            background: rgba(80, 80, 80, 0.5);
            border-left: 3px solid #888;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-item:hover {
            background: rgba(100, 100, 100, 0.7);
            border-left-color: #f0f0f0;
        }

        .game-item.active {
            background: rgba(136, 136, 136, 0.5);
            border-left-color: #f0f0f0;
        }

        .game-item-title {
            font-size: 16px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .game-item-desc {
            font-size: 12px;
            color: #ccc;
            letter-spacing: 1px;
        }

        .game-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .game-item.locked:hover {
            background: rgba(80, 80, 80, 0.5);
            border-left-color: #888;
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }

        .sidebar-overlay.show {
            display: block;
        }

        .stats-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.9);
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 50;
            min-width: 150px;
        }

        .stats-title {
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 8px;
        }

        .stats-value {
            font-size: 20px;
            letter-spacing: 2px;
            color: #f0f0f0;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stats-value:last-child {
            margin-bottom: 0;
        }

        .content {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 32px;
            letter-spacing: 8px;
            margin-bottom: 20px;
            font-weight: normal;
            text-transform: uppercase;
        }

        .description {
            font-size: 14px;
            line-height: 1.8;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: #ccc;
        }

        .game-container {
            position: relative;
            width: 600px;
            height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .score {
            position: absolute;
            top: 20px;
            font-size: 28px;
            font-weight: bold;
            letter-spacing: 3px;
            color: #f0f0f0;
            z-index: 10;
        }

        .main-circle {
            position: absolute;
            width: 500px;
            height: 500px;
            border-radius: 50%;
            background-color: #f0f0f0;
            box-shadow: 0 0 30px rgba(240, 240, 240, 0.3);
            transition: width 0.5s ease, height 0.5s ease;
        }

        .main-circle::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: 
                radial-gradient(circle at 50% 0%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 93% 7%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 100% 50%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 93% 93%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 50% 100%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 7% 93%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 0% 50%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%),
                radial-gradient(circle at 7% 7%, transparent 88%, #f0f0f0 88%, #f0f0f0 95%, transparent 95%);
        }

        .player {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #555;
            border: 2px solid #777;
            transform-origin: center;
            transition: all 0.1s ease;
            z-index: 20;
        }

        .spike {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 42px solid #f0f0f0;
            z-index: 15;
            transform-origin: bottom center;
            transition: transform 0.25s ease;
        }

        .spike.extended {
            transform: scale(1);
        }

        .spike.retracted {
            transform: scale(0);
        }

        .spike.retracting {
            transition-duration: 0.75s;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(42, 42, 42, 0.95);
            padding: 50px;
            border: 3px solid #888;
            display: none;
            z-index: 100;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 36px;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }

        .game-over p {
            font-size: 20px;
            margin-bottom: 30px;
            color: #ccc;
        }

        .restart-button {
            padding: 15px 50px;
            border: 2px solid #888;
            background-color: #888;
            color: #2a2a2a;
            font-size: 18px;
            cursor: pointer;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .restart-button:hover {
            background-color: #f0f0f0;
            border-color: #f0f0f0;
        }

        .start-message {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: #888;
            cursor: pointer;
            animation: pulse 2s ease-in-out infinite;
            z-index: 25;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(136, 136, 136, 0.5);
        }

        .start-message.hidden {
            display: none;
        }

        #character-container {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            height: 280px;
            z-index: 24;
            pointer-events: none;
        }

        #character-container.hidden {
            display: none;
        }

        #character-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <div class="sidebar" id="sidebar">
        <div class="sidebar-title">Games</div>
        <div class="game-item active">
            <div class="game-item-title">The Beginnings</div>
            <div class="game-item-desc">Orbital jumping game</div>
        </div>
        <div class="game-item locked">
            <div class="game-item-title">The Ascent</div>
            <div class="game-item-desc">Coming soon...</div>
        </div>
        <div class="game-item locked">
            <div class="game-item-title">The Journey</div>
            <div class="game-item-desc">Coming soon...</div>
        </div>
        <div class="game-item locked">
            <div class="game-item-title">The Final</div>
            <div class="game-item-desc">Coming soon...</div>
        </div>
    </div>

    <div class="header">
        <button class="menu-icon">☰</button>
        <div class="lang-sound">
            <button class="lang">EN</button>
            <button class="sound">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
            </button>
        </div>
    </div>

    <div class="content">
        <h1 class="title">The Beginnings</h1>
        <p class="description">
            Press SPACE to jump • Avoid the spikes
        </p>
    </div>

    <div class="game-container" id="gameContainer">
        <div class="score" id="score">0</div>
        
        <div class="main-circle"></div>
        <div class="player" id="player"></div>
        
        <div id="character-container"></div>
        <div class="start-message" id="startMessage">Click to Start</div>

        <div class="game-over" id="gameOver">
            <h2>GAME OVER</h2>
            <p id="finalScore">Score: 0</p>
            <button class="restart-button" id="restartButton">Play Again</button>
        </div>
    </div>

    <div class="stats-box">
        <div class="stats-title">High Score</div>
        <div class="stats-value" id="highScore">0</div>
        <div class="stats-title">Last Score</div>
        <div class="stats-value" id="lastScore">0</div>
    </div>

    <script>
        const gameContainer = document.getElementById('gameContainer');
        const player = document.getElementById('player');
        const mainCircle = document.querySelector('.main-circle');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const startMessage = document.getElementById('startMessage');

        let score = 0;
        let highScore = 0;
        let lastScore = 0;
        let angle = 0;
        let radius = 220;
        let playerDistance = 245;
        let isJumping = false;
        let jumpCount = 0;
        let jumpLevel = 0;
        let jumpResetTimeoutId = null;
        let isGameOver = false;
        let gameStarted = false;
        let rotationSpeed = 0.9;
        let spikes = [];
        let currentPattern = [];
        let lastPatternAngle = 0;
        let gameLoop;
        let hasCompletedFirstRotation = false;
        let totalRotations = 0;
        const rotationsBeforeDynamics = 3;

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function generatePattern(playerAngle) {
            const pattern = [];
            const numSpikes = 2 + Math.floor(Math.random() * 2);
            const startAngle = playerAngle + 90;
            for (let i = 0; i < numSpikes; i++) {
                const baseAngle = startAngle + (i / numSpikes) * 200;
                const randomOffset = (Math.random() - 0.5) * 24;
                let spikeAngle = (baseAngle + randomOffset) % 360;
                pattern.push({
                    angle: spikeAngle,
                    element: null,
                    isExtended: false,
                    hasBeenPassed: false,
                    hasBeenApproached: false,
                    stackCount: 1 + Math.floor(Math.random() * 2)
                });
            }
            return pattern;
        }

        function createSpikes() {
            if (!hasCompletedFirstRotation) return;

            currentPattern.forEach((spikeData) => {
                const baseAngle = spikeData.angle;
                const stack = spikeData.stackCount || 1;
                const groupId = Math.random().toString(36);
                
                for (let k = 0; k < stack; k++) {
                    const angleOffset = (k - (stack - 1) / 2) * 6;
                    const spike = {
                        ...spikeData,
                        angle: (baseAngle + angleOffset + 360) % 360,
                        element: document.createElement('div'),
                        isExtended: false,
                        hasBeenPassed: false,
                        hasBeenApproached: false,
                        halfWidth: 10 + Math.floor(Math.random() * 8),
                        height: 48,
                        retractTimeoutId: null,
                        lastRelativeDiff: null,
                        groupId: groupId,
                        isGroupLeader: k === 0
                    };

                    spike.element.classList.add('spike');
                    spike.element.classList.add('retracted');
                    gameContainer.appendChild(spike.element);
                    spike.element.style.borderLeft = spike.halfWidth + 'px solid transparent';
                    spike.element.style.borderRight = spike.halfWidth + 'px solid transparent';
                    spike.element.style.borderBottom = spike.height + 'px solid #f0f0f0';
                    
                    spikes.push(spike);
                    updateSpikePosition(spike);
                }
            });
        }

        function extendSpike(spike) {
            if (!spike.isExtended) {
                spike.isExtended = true;
                spike.element.classList.remove('retracting');
                spike.element.classList.remove('retracted');
                spike.element.classList.add('extended');
                updateSpikePosition(spike);
            }
        }

        function retractSpike(spike) {
            if (spike.isExtended) {
                spike.isExtended = false;
                spike.element.classList.add('retracting');
                spike.element.classList.remove('extended');
                spike.element.classList.add('retracted');
                updateSpikePosition(spike);
            }
        }

        function updateSpikePosition(spike) {
            const centerX = 300;
            const centerY = 300;
            const spikeDistance = radius - 1;
            
            const x = centerX + Math.cos(spike.angle * Math.PI / 180) * spikeDistance;
            const y = centerY + Math.sin(spike.angle * Math.PI / 180) * spikeDistance;
            
            spike.element.style.left = (x - spike.halfWidth) + 'px';
            spike.element.style.top = (y - spike.height) + 'px';
            
            const scaleValue = spike.isExtended ? 1 : 0;
            spike.element.style.transform = `rotate(${spike.angle + 90}deg) scale(${scaleValue})`;
        }

        function updateCircleSize() {
            playerDistance = radius + 25;
            mainCircle.style.width = (radius * 2) + 'px';
            mainCircle.style.height = (radius * 2) + 'px';
        }

        function applyRandomDynamics() {
            if (totalRotations < rotationsBeforeDynamics) return;

            if (Math.random() < 0.012) {
                const delta = (Math.random() * 0.8) - 0.4;
                rotationSpeed = clamp(rotationSpeed + delta, 0.6, 2.6);
            }

            if (Math.random() < 0.006) {
                const deltaR = (Math.random() * 30) - 15;
                radius = clamp(radius + deltaR, 160, 260);
                updateCircleSize();
                spikes.forEach(s => updateSpikePosition(s));
            }
        }

        function updatePlayerPosition() {
            const centerX = 300;
            const centerY = 300;
            
            const jumpOffset = jumpLevel === 0 ? 0 : (jumpLevel === 1 ? 42 : (jumpLevel === 2 ? 70 : 95));
            const distance = playerDistance + jumpOffset;
            
            const x = centerX + Math.cos(angle * Math.PI / 180) * distance - 12;
            const y = centerY + Math.sin(angle * Math.PI / 180) * distance - 12;
            
            player.style.left = x + 'px';
            player.style.top = y + 'px';
        }

        function jump() {
            if (isGameOver || !gameStarted) return;
            if (jumpCount >= 3) return;
            jumpCount += 1;
            isJumping = true;
            jumpLevel = Math.min(3, jumpCount);
            if (jumpResetTimeoutId) clearTimeout(jumpResetTimeoutId);
            jumpResetTimeoutId = setTimeout(() => {
                isJumping = false;
                jumpCount = 0;
                jumpLevel = 0;
                jumpResetTimeoutId = null;
            }, 300);
        }

        function checkSpikePassing() {
            return;
        }

        function updateSpikeApproach() {
            const playerAngle = angle % 360;
            const processedGroups = new Set();
            
            spikes.forEach(spike => {
                if (spike.isExtended) return;
                if (processedGroups.has(spike.groupId)) return;
                
                let spikeAngle = spike.angle % 360;
                let diff = playerAngle - spikeAngle;
                while (diff > 180) diff -= 360;
                while (diff < -180) diff += 360;
                
                if (diff < -12 && diff > -60) {
                    const groupSpikes = spikes.filter(s => s.groupId === spike.groupId);
                    groupSpikes.forEach(groupSpike => {
                        extendSpike(groupSpike);
                    });
                    processedGroups.add(spike.groupId);
                }
            });
        }

        function checkCollisions() {
            if (isJumping) return false;
            
            const playerAngle = angle % 360;
            
            for (let spike of spikes) {
                if (!spike.isExtended) continue;
                
                let spikeAngle = spike.angle % 360;
                let diff = Math.abs(playerAngle - spikeAngle);
                
                if (diff > 180) diff = 360 - diff;
                
                if (diff < 3) {
                    return true;
                }
            }
            
            return false;
        }

        function update() {
            if (isGameOver || !gameStarted) return;

            angle += rotationSpeed;
            
            if (angle >= 360) {
                angle -= 360;
                lastPatternAngle -= 360;
                totalRotations++;
                
                if (!hasCompletedFirstRotation) {
                    hasCompletedFirstRotation = true;
                }
                
                updateCircleSize();

                spikes.forEach(spike => {
                    if (spike.element) {
                        spike.element.remove();
                    }
                });
                spikes = [];
            }
            
            updatePlayerPosition();
            updateSpikeApproach();

            if (hasCompletedFirstRotation && angle - lastPatternAngle >= 240) {
                lastPatternAngle = angle;
                currentPattern = generatePattern(angle);
                createSpikes();
            }

            checkSpikePassing();

            if (hasCompletedFirstRotation && checkCollisions()) {
                gameOver();
            }

            applyRandomDynamics();

            score += 0.1;
            scoreDisplay.textContent = Math.floor(score);
        }

        function retractAllSpikesNow() {
            return;
        }

        function gameOver() {
            isGameOver = true;
            gameOverScreen.classList.add('show');
            finalScoreDisplay.textContent = `Score: ${Math.floor(score)}`;
            
            // Update last score and high score
            lastScore = Math.floor(score);
            if (lastScore > highScore) {
                highScore = lastScore;
            }
            
            // Update display
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('lastScore').textContent = lastScore;
            
            clearInterval(gameLoop);
        }

        function restartGame() {
            // Stop the game loop
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }
            
            isGameOver = false;
            gameStarted = false;
            score = 0;
            angle = 0;
            rotationSpeed = 0.9;
            lastPatternAngle = 0;
            isJumping = false;
            jumpCount = 0;
            jumpLevel = 0;
            hasCompletedFirstRotation = false;
            totalRotations = 0;
            radius = 220;
            playerDistance = 245;
            
            mainCircle.style.width = (radius * 2) + 'px';
            mainCircle.style.height = (radius * 2) + 'px';
            
            scoreDisplay.textContent = '0';
            gameOverScreen.classList.remove('show');
            startMessage.classList.remove('hidden');
            showCharacter();
            
            spikes.forEach(spike => {
                if (spike.element) {
                    spike.element.remove();
                }
            });
            spikes = [];
            
            updatePlayerPosition();
        }

        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            startMessage.classList.add('hidden');
            hideCharacter();
            angle = 0;
            updatePlayerPosition();
            currentPattern = generatePattern(angle);
            gameLoop = setInterval(update, 1000 / 60);
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameStarted && !isGameOver) {
                    startGame();
                } else if (gameStarted && !isGameOver) {
                    jump();
                }
                // Do nothing if game is over - user must click Play Again button
            }
        });

        gameContainer.addEventListener('click', (e) => {
            // Don't handle clicks on the restart button or game over screen
            if (e.target.id === 'restartButton' || e.target.closest('.game-over')) {
                return;
            }
            
            if (!gameStarted && !isGameOver) {
                startGame();
            } else if (gameStarted && !isGameOver) {
                jump();
            }
        });

        document.querySelector('.menu-icon').addEventListener('click', function() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('show');
        });

        document.getElementById('sidebarOverlay').addEventListener('click', function() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            sidebar.classList.remove('open');
            overlay.classList.remove('show');
        });

        document.querySelector('.lang').addEventListener('click', function() {
            this.textContent = this.textContent === 'EN' ? 'KOR' : 'EN';
        });

        let soundOn = true;
        const soundButton = document.querySelector('.sound');
        soundButton.addEventListener('click', function() {
            soundOn = !soundOn;
            if (soundOn) {
                this.classList.remove('muted');
            } else {
                this.classList.add('muted');
            }
        });

        window.addEventListener('load', () => {
            mainCircle.style.width = (radius * 2) + 'px';
            mainCircle.style.height = (radius * 2) + 'px';
            updatePlayerPosition();
        });

        document.getElementById('restartButton').addEventListener('click', () => {
            restartGame();
        });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 3D Character code
        let characterScene, characterCamera, characterRenderer, characterModel;
        let characterLeftLeg, characterRightLeg, characterLeftArm, characterRightArm;
        let characterWalkTime = 0;
        let characterAnimationId = null;

        function initCharacter() {
            const container = document.getElementById('character-container');
            
            // Scene
            characterScene = new THREE.Scene();
            characterScene.background = null; // Transparent

            // Camera
            characterCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            characterCamera.position.set(0, 1.5, 4);
            characterCamera.lookAt(0, 1, 0);

            // Renderer
            characterRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            characterRenderer.setSize(280, 280);
            characterRenderer.shadowMap.enabled = false;
            container.appendChild(characterRenderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            characterScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 5);
            characterScene.add(directionalLight);

            // Create character
            createCharacter();
            
            // Start animation
            animateCharacter();
        }

        function createCharacter() {
            characterModel = new THREE.Group();
            characterModel.position.y = 1.2;
            characterScene.add(characterModel);

            const material = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.6
            });

            // HEAD
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), material);
            head.position.y = 1;
            characterModel.add(head);

            // BODY
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), material);
            body.position.y = 0.3;
            characterModel.add(body);

            // LEFT LEG
            characterLeftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.7, 0.15), material);
            characterLeftLeg.position.set(-0.15, -0.25, 0);
            characterModel.add(characterLeftLeg);

            // RIGHT LEG
            characterRightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.7, 0.15), material);
            characterRightLeg.position.set(0.15, -0.25, 0);
            characterModel.add(characterRightLeg);

            // LEFT ARM
            characterLeftArm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.6, 0.12), material);
            characterLeftArm.position.set(-0.42, 0.35, 0);
            characterModel.add(characterLeftArm);

            // RIGHT ARM
            characterRightArm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.6, 0.12), material);
            characterRightArm.position.set(0.42, 0.35, 0);
            characterModel.add(characterRightArm);

            // Rotate character to show diagonal side view
            characterModel.rotation.y = Math.PI * 0.75; // 135 degrees for diagonal view
        }

        function animateCharacterWalking() {
            characterWalkTime += 0.05;
            
            // Body bounce
            characterModel.position.y = 1.2 + Math.abs(Math.sin(characterWalkTime * 2)) * 0.08;
            
            // Leg swings
            characterLeftLeg.rotation.x = Math.sin(characterWalkTime) * 0.7;
            characterRightLeg.rotation.x = Math.sin(characterWalkTime + Math.PI) * 0.7;
            
            // Arm swings
            characterLeftArm.rotation.x = Math.sin(characterWalkTime + Math.PI) * 0.6;
            characterRightArm.rotation.x = Math.sin(characterWalkTime) * 0.6;
        }

        function animateCharacter() {
            characterAnimationId = requestAnimationFrame(animateCharacter);
            animateCharacterWalking();
            characterRenderer.render(characterScene, characterCamera);
        }

        function stopCharacterAnimation() {
            if (characterAnimationId) {
                cancelAnimationFrame(characterAnimationId);
                characterAnimationId = null;
            }
        }

        function hideCharacter() {
            document.getElementById('character-container').classList.add('hidden');
            stopCharacterAnimation();
        }

        function showCharacter() {
            const container = document.getElementById('character-container');
            container.classList.remove('hidden');
            if (!characterRenderer) {
                initCharacter();
            } else {
                animateCharacter();
            }
        }

        // Initialize character on page load
        window.addEventListener('load', () => {
            initCharacter();
        });
    </script>
</body>
</html>
